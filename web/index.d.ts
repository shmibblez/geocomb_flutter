/**
 * map orientation, changes where hexagons are placed
 * - ECEF (default): standard way of doing stuff, still pretty good
 * - dymaxion: good for icosahedron, there are no vertices on land, which means no pentagons
 * - NOTE: only ECEF is supported for hash generation
 */
export declare type MapOrientation = "dymaxion" | "ECEF";
/**
 * rotation method, changes how point coordinates are generated
 * - gnomonic (default): phex areas are smaller towards vertices, but phexes are more symmetrical
 * - quaternion: phex areas are more uniform, but phexes get distorted a bit more
 * - NOTE: only gnomonic is supported for hash generation
 */
export declare type RotationMethod = "gnomonic" | "quaternion";
/**
 * hash properties, stores point row & col for res on geocomb grid
 */
export declare class HashProperties {
  res: number;
  row: number;
  col: number;
  private _mo;
  private _rm;
  get mo(): MapOrientation;
  get rm(): RotationMethod;
  constructor(
    res: number,
    row: number,
    col: number,
    mo: MapOrientation | any,
    rm: RotationMethod | any
  );
}
/**
 * Icosahedron class, used for hash generation
 */
export declare class Icosahedron {
  private _ico;
  private _mo;
  private _rm;
  get mo(): MapOrientation;
  get rm(): RotationMethod;
  /**
   * since geocomb-web runs on WebAssembly, need to wait for it to be ready
   * @returns whether runtime is ready for geocomb-web
   */
  static get isReady(): boolean;
  /**
   * Icosahedron constructor
   * @param mapOrientation Icosahedron orientation on globe map
   * @param rotationMethod technique to use to rotate points
   */
  constructor(mapOrientation?: MapOrientation, rotationMethod?: RotationMethod);
  /**
   *
   * @param mapOrientation Icosahedron orientation on globe map
   * @param rotationMethod technique to use to rotate points
   * @returns Promise that resolves with new Icosahedron instance
   */
  static onReady(
    mapOrientation?: MapOrientation,
    rotationMethod?: RotationMethod
  ): Promise<Icosahedron>;
  /**
   * generates point on globe, for use with Icosahedron#hash()
   * @param lat point latitude
   * @param lon point longitude
   * @retunrs Point3
   */
  pointFromCoords(lat: number, lon: number): Point3;
  /**
   * generates hash for point
   * @param point point to hash
   * @param res geocomb grid resolution
   * @returns HashProperties for point on geocomb grid
   */
  hash(point: Point3, res: number): HashProperties;
  /**
   * parses hash, returning GPoint3 that's also phex center
   * @throws errors if invalid rotation methods or row or col numbers are provided
   * @param props hash properties
   * @returns GPoint3 that's also a phex center
   */
  parseHash(props: HashProperties): GPoint3;
}
/**
 * Point class, used for storing locations
 */
export declare class Point3 {
  x: number;
  y: number;
  z: number;
  triNum: number;
  isPC: boolean;
  /**
   * Point3 constructor
   * @param x point's x coordinate
   * @param y point's y coordinate
   * @param z point's z coordinate
   */
  constructor(x: number, y: number, z: number, triNum?: number, isPC?: boolean);
}
/**
 * GPoint3 class, generated by Icosahedron, additionally stores row and col on geocomb grid for res
 */
export declare class GPoint3 extends Point3 {
  row: number;
  col: number;
  res: number;
  private _mo;
  private _rm;
  get mo(): MapOrientation;
  get rm(): RotationMethod;
  /**
   *
   * @param x
   * @param y
   * @param z
   * @param res
   * @param row
   * @param col
   * @param mo
   * @param rm
   * @param triNum
   * @param isPC
   */
  constructor(
    x: number,
    y: number,
    z: number,
    res: number,
    row: number,
    col: number,
    mo: MapOrientation | any,
    rm: RotationMethod | any,
    triNum?: number,
    isPC?: boolean
  );
}
